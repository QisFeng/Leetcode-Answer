1.TwoSum
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map=new HashMap();
        //num,idx
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(target-nums[i])){
                return new int[] {map.get(target-nums[i]),i};
            }
            map.put(nums[i],i);
        }
        throw new IllegalArgumentException("No");
    }
}

2.add two number
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy=new ListNode(0);
        ListNode curr=dummy;
        int carry=0;
        while(l1!=null||l2!=null||carry!=0){
            if(l1!=null){
                carry+=l1.val;
                l1=l1.next;
            }
            if(l2!=null){
                carry+=l2.val;
                l2=l2.next;
            }
            curr.next=new ListNode(carry%10);
            carry=carry/10;
            curr=curr.next;
        }
        
        return dummy.next;
    }
}

3. Longest Substring Without Repeating Characters
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length()<2) return s.length();
        int maxl=0;
        int left=0,right=0;
        int[] dp=new int[256];
        while(right<s.length()){
            char c=s.charAt(right);
            dp[c]++;
            while(dp[c]>1){
                dp[s.charAt(left++)]--;
            }
            maxl=Math.max(maxl,right-left+1);
            right++;
        }
    }
}

5. Longest Palindromic Substring
class Solution {
    public String longestPalindrome(String s) {
        if(s.length()<2) return s;
        int maxl=0;
        int index=0;
        for(int i=0;i<s.length();i++){
            //odd
            int[] pos=palHelp(s,i,i);
            if(pos[1]-pos[0]>maxl){
                index=pos[0];
                maxl=pos[1]-pos[0];
            }
            //even
            pos=palHelp(s,i,i+1);
            if(pos[1]-pos[0]>maxl){
                index=pos[0];
                maxl=pos[1]-pos[0];
            }
        }
        return s.substring(index,index+maxl);
    }
    
    public int[] palHelp(String s, int i, int j){
        while(i>=0&&j<s.length()&&s.charAt(i)==s.charAt(j)){
            i--;
            j++;
        }
        return new int[] {i+1,j};
    }
}

6. ZigZag Conversion
class Solution {
    public String convert(String s, int numRows) {
        if(numRows==1) return s;
        List<StringBuilder> ans=new ArrayList<>();
        boolean down=false;
        int count=0;
        for(int i=0;i<numRows;i++){
            ans.add(new StringBuilder());
        }
        for(int i=0;i<s.length();i++){
            ans.get(count).append(s.charAt(i));
            if(count==0||count==numRows-1) down=!down;
            if(down==true) count++;
            else count--;
        }
        StringBuilder sb=new StringBuilder();
        for(int i=0;i<numRows;i++){
            sb.append(ans.get(i));
        }
        return sb.toString();
    }
}

7. Reverse Integer
class Solution {
    public int reverse(int x) {
        int rev=0;
        while(x!=0){
            int temp=x%10;
            if(rev*10+temp>Integer.MAX_VALUE||rev*10+temp<Integer.MIN_VALUE||rev>Integer.MAX_VALUE/10||rev<Integer.MIN_VALUE/10){
            return 0;
        }
            rev=rev*10+temp;
            x=x/10;
        }
        
        return rev;
    }
}

9. Palindrome Number
class Solution {
    public boolean isPalindrome(int x) {
        if(x<0) return false;
        
        int rev=0;
        int ori=x;
        while(x>0){
            int temp=x%10;
            if(rev>Integer.MAX_VALUE/10||rev<Integer.MIN_VALUE/10||rev*10+temp>Integer.MAX_VALUE||rev*10+temp<Integer.MIN_VALUE){
                return false;
            }
            rev=rev*10+temp;
            x=x/10;
        }
    
        return rev==ori;
   }
}

11. Container With Most Water
class Solution {
    public int maxArea(int[] height){
        int left=0;
        int right=height.length-1;
        int maxArea=0;
        while(left<right){
            int leh=height[left];
            int rih=height[right];
            int curArea=Math.min(leh,rih)*(right-left);
            maxArea=Math.max(maxArea,curArea);
            if(leh>rih){
                while(left<right&&rih>=height[right])
                    right--;
            }else{
                while(left<right&&leh>=height[left])
                    left++;
            }
        }
        return maxArea;
    }
}

12. Integer to Roman
class Solution {
    public String intToRoman(int num) {
        int[] nums={1000,900,500,400,100,90,50,40,10,9,5,4,1};
        String[] roman={"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
        StringBuilder ans=new StringBuilder();
        for(int i=0;i<nums.length;i++){
            if(num<0) break;
            if(num<nums[i]) continue;
            while(num>=nums[i]){
                ans.append(roman[i]);
                num-=nums[i];
            }
        }
        return ans.toString();
    }
}

13. Roman to Integer
class Solution {
    public int romanToInt(String s) {
        if(s.length()==0) return 0;
        int ans=0;
        char prev=' ';
        for(char c:s.toCharArray()){
            ans+=convert(c,prev);
            prev=c;
        }
        return ans;
    }
    
    public int convert(char c, char prev){
        switch(c){
            case 'I': 
                return 1;
            case 'V':
                return prev=='I'? 3:5;
            case 'X':
                return prev=='I'? 8:10;
            case 'L':
                return prev=='X'? 30:50;
            case 'C':
                return prev=='X'? 80:100;
            case 'D':
                return prev=='C'? 300:500;
            case 'M':
                return prev=='C'? 800:1000;
        }
        throw new IllegalArgumentException("No such roman char");
    }
}

14. Longest Common Prefix
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs.length==0) return "";
        int len=0;
        for(int i=0;i<strs[0].length();i++){
            for(int j=1;j<strs.length;j++){
                if(strs[j].length()<=i||strs[j].charAt(i)!=strs[0].charAt(i))
                    return strs[0].substring(0,i);
            }
            len++;
        }
        return strs[0].substring(0,len);
    }
}

15. 3Sum
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans=new ArrayList<>();
        if(nums.length<3) return ans;
        
        Arrays.sort(nums);
        
        for(int i=0;i<nums.length-2;i++){
            if(nums[i]>0) break;
            int left=i+1;
            int right=nums.length-1;
            while(left<right){
                int sum=nums[i]+nums[left]+nums[right];
                if(sum==0){
                    List<Integer> list=Arrays.asList(nums[i],nums[left],nums[right]);
                    if(!ans.contains(list)) ans.add(list);
                    left++;
                    right--;
                }else if(sum<0){
                    left++;
                }else{
                    right--;
                }
            }
        }
        
        return ans;
    }
}

16. 3Sum Closest
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int ans=0;
        int dif=Integer.MAX_VALUE;
        for(int i=0;i<nums.length-2;i++){
            int left=i+1;
            int right=nums.length-1;
            while(left<right){
                int sum=nums[i]+nums[left]+nums[right];
                if(sum==target){
                    return sum;
                }else if(sum<target){
                    int tempDif=target-sum;
                    if(tempDif<dif){
                        dif=tempDif;
                        ans=sum;
                    }
                    left++;
                }else{
                    int tempDif=sum-target;
                    if(tempDif<dif){
                        dif=tempDif;
                        ans=sum;
                    }
                    right--;
                }
            }
        }
        return ans;
    }
}

17. Letter Combinations of a Phone Number
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> ans=new ArrayList<>();
        if(digits.length()==0) return ans;
        Map<Character,String> map=new HashMap<>();
        map.put('2',"abc");
        map.put('3',"def");
        map.put('4',"ghi");
        map.put('5',"jkl");
        map.put('6',"mno");
        map.put('7',"pqrs");
        map.put('8',"tuv");
        map.put('9',"wxyz");
        
        ans.add("");
        for(char num:digits.toCharArray()){
            char[] ca=map.get(num).toCharArray();
            List<String> preset=new ArrayList<>();
            for(String s: ans){
                for(char c: ca){
                    preset.add(s+c);
                }
            }
            ans=preset;
        }
        return ans;
    }
}

18. 4Sum
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> ans=new ArrayList<>();
        if(nums.length<4) return ans;
        Arrays.sort(nums);
        for(int i=0;i<nums.length-3;i++){
            for(int j=i+1;j<nums.length-2;j++){
                int left=j+1;
                int right=nums.length-1;
                while(left<right){
                    int sum=nums[i]+nums[j]+nums[left]+nums[right];
                    if(sum==target){
                        List<Integer> list=Arrays.asList(nums[i],nums[j],nums[left],nums[right]);
                        if(!ans.contains(list)) ans.add(list);
                        left++;
                        right--;
                    }else if(sum<target){
                        left++;
                    }else{
                        right--;
                    }
                }
            }
        }
        
        return ans;
    }
}

20. Valid Parentheses
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack=new Stack<>();
        Map<Character,Character> map = new HashMap<>();
        map.put(')','(');
        map.put(']','[');
        map.put('}','{');
        for(char c: s.toCharArray()){
            //if it is close parenthese
            if(map.containsKey(c)){
                if(stack.isEmpty()) return false;
                if(map.get(c)!=stack.peek()) return false;
                
                stack.pop();
            }else{
                //if it is open
                stack.push(c);
            }        
        }
            
        return stack.isEmpty();
    }
}

26. Remove Duplicates from Sorted Array
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length==0) return 0;
        int slow=0;
        int fast=1;
        while(fast<nums.length){
            if(nums[slow]!=nums[fast]){
                nums[++slow]=nums[fast];
            }
            fast++;
        }
        return slow+1;
    }
}
27. Remove Element
class Solution {
    public int removeElement(int[] nums, int val) {
        int slow=0;
        for(int num:nums){
            if(num!=val){
                nums[slow++]=num;
            }
        }
        return slow;
    }
}

28. Implement strStr()
class Solution {
    public int strStr(String haystack, String needle) {
        if(needle.length()==0) return 0;
        for(int i=0;i<haystack.length()-needle.length()+1;i++){
            if(haystack.charAt(i)==needle.charAt(0)){
                int j=1;
                while(j<needle.length()){
                    if(haystack.charAt(i+j)!=needle.charAt(j)) break;
                    j++;
                }
                if(j==needle.length()) return i;
            }
        }
        return -1;
    }
}

35. Search Insert Position
class Solution {
    public int searchInsert(int[] nums, int target) {
        if(nums.length==0) return 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]>=target) return i; 
        }
        return nums.length;
    }
}
38. Count and Say
class Solution {
    public String countAndSay(int n) {
        StringBuilder curr=new StringBuilder("1");
        StringBuilder prev;
        for(int i=1;i<n;i++){
            prev=curr;
            curr=new StringBuilder();
            int count=1;
            char say=prev.charAt(0);
            for(int j=1;j<prev.length();j++){
                if(prev.charAt(j)==say) count++;
                else{
                    curr.append(count).append(say);
                    say=prev.charAt(j);
                    count=1;
                }
            }
            curr.append(count).append(say);
        }
        return curr.toString();
    }
}
48. Rotate Image
class Solution {
    public void rotate(int[][] matrix) {
        int n=matrix.length;
        for(int i=0;i<(n+1)/2;i++){
            for(int j=0;j<n/2;j++){
                int temp=matrix[n-j-1][i];
                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];
                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];
                matrix[j][n-i-1]=matrix[i][j];
                matrix[i][j]=temp;
            }
        }
    }
}

49. Group Anagrams
RT:O(n*k logk),n is strs.length, k is the longest str length
class Solution {  
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String,List<String>> map=new HashMap<>();
        for(String str:strs){
            char[] ca=str.toCharArray();
            Arrays.sort(ca);
            String k=String.valueOf(ca);
            if(!map.containsKey(k)) map.put(k,new ArrayList<>());
            map.get(k).add(str);
        }
        
        return new ArrayList<>(map.values());
    }
}
RT:O(n*k*26)->O(nk) 
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String,List<String>> map=new HashMap<>();
        for(String str:strs){
            int[] count=new int[26];
            for(char c:str.toCharArray()) count[c-'a']++;
            String k=Arrays.toString(count);
            if(!map.containsKey(k)) map.put(k,new ArrayList<>());
            map.get(k).add(str);
        }
        
        return new ArrayList<>(map.values());
    }
}

53. Maximum Subarray
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length==0) return Integer.MIN_VALUE;
        int curr_max=nums[0],ans=nums[0];
        for(int i=1;i<nums.length;i++){
            curr_max=Math.max(nums[i],curr_max+nums[i]);
            ans=Math.max(curr_max,ans);
        }
        return ans;
    }
}
58. Length of Last Word
class Solution {
    public int lengthOfLastWord(String s) {
        s=s.trim();
        int i=s.lastIndexOf(' ');
        return s.length()-i-1;
    }
}

62. Unique Paths
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp=new int[m][n];
        for(int i=0;i<m;i++){
            dp[i][0]=1;
        }
        for(int i=1;i<n;i++){
            dp[0][i]=1;
        }
        for(int k=1;k<m;k++){
            for(int j=1;j<n;j++){
                dp[k][j]=dp[k-1][j]+dp[k][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}

63. Unique Paths II
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m=obstacleGrid.length;
        int n=obstacleGrid[0].length;
        int[][] dp=new int[m][n];
        for(int i=0;i<m;i++){
            if(obstacleGrid[i][0]==1){
                while(i<m){
                    dp[i++][0]=0;
                }
                break;
            }
            dp[i][0]=1;
        }
        for(int i=0;i<n;i++){
            if(obstacleGrid[0][i]==1){
                while(i<n){
                    dp[0][i++]=0;
                }
                break;
            }
            dp[0][i]=1;
        }
        for(int k=1;k<m;k++){
            for(int l=1;l<n;l++){
                if(obstacleGrid[k][l]==1) dp[k][l]=0;
                else dp[k][l]=dp[k-1][l]+dp[k][l-1];
            }
        }
        return dp[m-1][n-1];
    }
}

66. Plus One
class Solution {
    public int[] plusOne(int[] digits) {
        int len=digits.length;
        
        for(int i=len-1;i>=0;i--){
            if(digits[i]==9) digits[i]=0;
            else{
                digits[i]++;
                return digits;
            }
        }
        int[] ans=new int[len+1];
        ans[0]=1;
        return ans;
    }
}

67. Add Binary
class Solution {
    public String addBinary(String a, String b) {
        int carry=0;
        int i=a.length()-1;
        int j=b.length()-1;
        StringBuilder ans=new StringBuilder();
        while(i>=0||j>=0){
            if(i>=0) carry+=a.charAt(i--)-'0';
            if(j>=0) carry+=b.charAt(j--)-'0';
            ans.append(carry%2);
            carry=carry/2;
        }
        if(carry==1) ans.append(carry);
        return ans.reverse().toString();
    }
}

70. Climbing Stairs
class Solution {
    public int climbStairs(int n) {
        if(n==1) return 1;
        int[] memo=new int[n];
        memo[0]=1;
        memo[1]=2;
        for(int i=2;i<n;i++){
            memo[i]=memo[i-1]+memo[i-2];
        }
        return memo[n-1];
    }
}

100. Same Tree
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null&&q==null) return true;
        if(p==null||q==null) return false;
        return p.val==q.val&&isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
    }
}

101. Symmetric Tree
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null) return true;
        if(root.left==null&&root.right==null) return true;
        return check(root.left,root.right);
    }
    public boolean check(TreeNode leftSide, TreeNode rightSide){
        if(leftSide==null&&rightSide==null) return true;
        if(leftSide==null||rightSide==null) return false;
        return leftSide.val==rightSide.val&&check(leftSide.left,rightSide.right)&&check(leftSide.right,rightSide.left);
    }
}

102. Binary Tree Level Order Traversal
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans=new ArrayList<>();
        if(root==null) return ans;
        Queue<TreeNode> q=new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            int size=q.size();
            List<Integer> list=new ArrayList<>();
            for(int i=0;i<size;i++){
                TreeNode curr=q.poll();
                if(curr.left!=null) q.add(curr.left);
                if(curr.right!=null) q.add(curr.right);
                list.add(curr.val);
            }
            ans.add(list);
        }
        return ans;
    }
}

103. Binary Tree Zigzag Level Order Traversal
BFS:
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans=new ArrayList<>();
        if(root==null) return ans;
        Boolean zigzag=false;
        Queue<TreeNode> q=new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            int size=q.size();
            List<Integer> level=new ArrayList<>();
            for(int i=0;i<size;i++){
                TreeNode curr=q.poll();
                if(!zigzag){
                    level.add(curr.val); 
                }else{
                    level.add(0,curr.val);
                }
                if(curr.left!=null) q.add(curr.left);
                if(curr.right!=null) q.add(curr.right);
            }
            ans.add(level);
            zigzag=!zigzag;
        }
        return ans;
    }
}
Recursive:
class Solution {
    List<List<Integer>> ans=new ArrayList<>();
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        
        traversal(root,0);
        return ans;
    }
    public void traversal(TreeNode root,int level){
        if(root==null) return;
        if(ans.size()<=level) ans.add(new ArrayList<Integer>());
        if(level%2==0){
            ans.get(level).add(root.val);
        }else{
            ans.get(level).add(0,root.val);
        }
        traversal(root.left,level+1);
        traversal(root.right,level+1);
    }
}

111. Minimum Depth of Binary Tree
class Solution {
    
    public int minDepth(TreeNode root) {
        if(root==null) return 0;
        if(root.left==null&&root.right==null) return 1;
        int left=minDepth(root.left)+1;
        int right=minDepth(root.right)+1;
        if(root.left==null) return right;
        if(root.right==null) return left;
        return Math.min(left,right);
    }
}

112. Path Sum
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root==null) return false;
        if(root.left==null&&root.right==null) return root.val==sum;
        return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);
    }
}

113.
class Solution {
    List<List<Integer>> ans=new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        if(root==null) return ans;
        Stack<Integer> path=new Stack<>();
        findPath(root,sum,path);
        return ans;
    }
    
    public void findPath(TreeNode root, int sum, Stack<Integer> path){
        path.push(root.val);
        if(root.left==null&&root.right==null){
            if(root.val==sum){
                ans.add(new ArrayList<>(path));
            }
        }
        if(root.left!=null) findPath(root.left,sum-root.val,path);
        if(root.right!=null) findPath(root.right,sum-root.val,path);
        path.pop();
    }
}

121. Best Time to Buy and Sell Stock
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length==0) return 0;
        int buy=prices[0];
        int profit=0;
        for(int price:prices){
            buy=Math.min(buy,price);
            profit=Math.max(price-buy,profit);
        }
        return profit;
    }
}

122. Best Time to Buy and Sell Stock II
class Solution {
    public int maxProfit(int[] prices) {
        int ans=0;
        for(int i=1;i<prices.length;i++){
            ans+=prices[i]-prices[i-1]>0? prices[i]-prices[i-1]:0;
        }
        return ans;
    }
}

129. Sum Root to Leaf Numbers
class Solution {
    int sum=0;
    public int sumNumbers(TreeNode root) {
        if(root==null) return sum;
        helper(root,root.val);
        return sum;
    }
    
    public void helper(TreeNode root, int value){
        
        if(root.left==null&&root.right==null){
            sum+=value;
            return;
        }
        
        if(root.left!=null) {
            int add=value*10+root.left.val;
            helper(root.left,add);
        }
        if(root.right!=null){
            int add=value*10+root.right.val;
            helper(root.right,add);
        }
        
    }
}

136. Single Number
class Solution {
    public int singleNumber(int[] nums) {
        Set<Integer> set=new HashSet<>();
        int sum=0;
        for(int num:nums){
            if(set.contains(num)){
                sum-=num;
            }else{
                set.add(num);
                sum+=num;
            }
        }
        return sum;
    }
}
//XOR: ^=, only keeps the difference
class Solution {
    public int singleNumber(int[] nums) {
        for(int i=1;i<nums.length;i++){
            nums[i] ^= nums[i-1];//XOR
        }
        return nums[nums.length-1];
    }
}

138. Copy List with Random Pointer
//Method 1: O(n) time and space, but only go over the linked list once
class Solution {
    Map<Node,Node> map=new HashMap<>();
    public Node copyRandomList(Node head) {
        if(head==null) return null;
        
        Node oldNode=head;
        map.put(oldNode,new Node(oldNode.val,null,null));
        while(oldNode!=null){
            //next
            map.get(oldNode).next=getPointer(oldNode.next);
            map.get(oldNode).random=getPointer(oldNode.random);
            oldNode=oldNode.next;
        }
        return map.get(head);
    }
    public Node getPointer(Node node){
        //clone node not created yet
        if(node==null) return null;
        if(!map.containsKey(node))
            map.put(node,new Node(node.val,null,null));
        return map.get(node);
    }
}
//Method 2:O(n) time and space, but go over the linked list twice
class Solution {
    public Node copyRandomList(Node head) {
        if(head==null) return null;
        Node curr=head;
        Map<Node,Node> map=new HashMap<>();
        //copy all node
        while(curr!=null){
            map.put(curr,new Node(curr.val,null,null));
            curr=curr.next;
        }
        curr=head;
        //connect pointer
        while(curr!=null){
            map.get(curr).next=map.get(curr.next);
            map.get(curr).random=map.get(curr.random);
            curr=curr.next;
        }
        return map.get(head);
    }
}

146. LRU Cache
class LRUCache {
    //fast lookup&fast removal at the tail and fast insertion at the head
    //if single linked list, it would cost O(n) to find the node
    int size,capacity;
    Map<Integer,ListNode> map=new HashMap<>();
    ListNode header,trailer;
    private class ListNode{
        ListNode prev,next;
        int key,val;
    }
    //key: key, value:Node
    public LRUCache(int capacity) {
        this.capacity=capacity;
        size=0;
        header=new ListNode();
        trailer=new ListNode();
        header.next=trailer;
        trailer.prev=header;
    }
    
    public int get(int key) {
        ListNode node=map.get(key);
        if(node==null) return -1;
        moveToHead(node);
        return node.val;
    }
    
    public void put(int key, int value) {
        ListNode node=map.get(key);
        if(node==null){
            ListNode newNode=new ListNode();
            newNode.key=key;
            newNode.val=value;
            map.put(key,newNode);
            addHead(newNode);
            size++;
            if(size>capacity){
                ListNode tail=trailer.prev;
                remove(tail);
                map.remove(tail.key);
                size--;
            }
        }else{
            node.val=value;
            map.put(key,node);
            moveToHead(node);
        }
    }
    
    private void moveToHead(ListNode node){
        remove(node);
        addHead(node);
    }
    private void addHead(ListNode node){
        header.next.prev=node;
        node.next=header.next;
        header.next=node;
        node.prev=header;
    }
    private void remove(ListNode node){
        node.prev.next=node.next;
        node.next.prev=node.prev;
    }
}

167. Two Sum II - Input array is sorted
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left=0;
        int right=numbers.length-1;
        while(left<right){
            if(target<numbers[left]) break;
            int sum=numbers[left]+numbers[right];
            if(sum==target) return new int[] {left+1,right+1};
            else if(sum<target) left++;
            else right--;
        }
        return new int[] {-1,-1};
    }
}

200. Number of Islands
class Solution {
    public int numIslands(char[][] grid) {
        
        int row=grid.length;
        if(row==0) return 0;
        int col=grid[0].length;
        //if visited, mark as 1
        int count=0;
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    count++;
                }
            }
        }
        return count;
    }
    public void dfs(char[][] grid,int r,int c){
        if(r<0||c<0||r>=grid.length||c>=grid[0].length||grid[r][c]=='0') return;
        grid[r][c]='0';
        dfs(grid,r-1,c);
        dfs(grid,r+1,c);
        dfs(grid,r,c-1);
        dfs(grid,r,c+1);
        
    }
}

206. Reverse Linked List
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null) return head;
        ListNode prev=null;
        ListNode memo=head.next;
        while(memo!=null){
            head.next=prev;
            prev=head;
            head=memo;
            memo=memo.next;
        }
        head.next=prev;
        return head;
    }
}

226. Invert Binary Tree
Recursive solution:
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null) return null;
        TreeNode temp=root.left;
        root.left=invertTree(root.right);
        root.right=invertTree(temp);
        return root;
    }   
}
iterative solution:
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null) return null;
        Queue<TreeNode> q=new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            TreeNode curr=q.poll();
            TreeNode temp=curr.left;
            curr.left=curr.right;
            curr.right=temp;
            if(curr.left!=null) q.add(curr.left);
            if(curr.right!=null) q.add(curr.right);
        }
        return root;
    }
}

234. Palindrome Linked List
O(n) time and O(1) space
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head==null||head.next==null) return true;
        ListNode curr=head;
        int count=0;//count is number of nodes
        while(curr!=null){
            count++;
            curr=curr.next;
        }
        int mid=0;
        if(count%2==0) mid=count/2;
        else mid=count/2+1;
        ListNode middle=head;
        while(mid>0){
            mid--;
            middle=middle.next;
        }
        ListNode tail=reverse(middle);
        while(tail!=null){
            if(head.val!=tail.val) return false;
            head=head.next;
            tail=tail.next;
        }
        return true;
    }
    
    public ListNode reverse(ListNode middle){
        if(middle.next==null) return middle;
        ListNode prev=null;
        ListNode memo=middle.next;
        while(memo!=null){
            middle.next=prev;
            prev=middle;
            middle=memo;
            memo=memo.next;
        }
        middle.next=prev;
        return middle;
    }
}
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head==null||head.next==null) return true;
        
        List<Integer> list=new ArrayList();
        while(head!=null){
            list.add(head.val);
            head=head.next;
        }
        int i=0,j=list.size()-1;
        while(i<j){
            //use.equals instead of !=
            if(!list.get(i).equals(list.get(j))) return false;
            i++;
            j--;
        }
        return true;
    }
}

242. Valid Anagram
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] count=new int[26];
        for(char cs:s.toCharArray()){
            count[cs-'a']++;
        }
        for(char ct:t.toCharArray()){
            count[ct-'a']--;
        }
        for(int i=0;i<26;i++){
            if(count[i]!=0) return false;
        }
        return true;
    }
}

252. Meeting Rooms
class Solution {
    public boolean canAttendMeetings(int[][] intervals) {
        if(intervals.length==0) return true;
        Arrays.sort(intervals,(n1,n2) -> (n1[0]-n2[0]));
        for(int i=1;i<intervals.length;i++){
            if(intervals[i][0]<intervals[i-1][1]) return false;
        
        }
        return true;
    }
}
253. Meeting Rooms II
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        if(intervals.length==0) return 0;
        Arrays.sort(intervals,(n1,n2)->(n1[0]-n2[0]));
        PriorityQueue<int[]> pq=new PriorityQueue<>((n1,n2)->n1[1]-n2[1]);
        for(int[] interval:intervals){
            if(pq.size()==0){
                pq.add(interval);
                continue;
            }
            int[] check=pq.peek();
            if(check[1]<=interval[0]) pq.poll();
            pq.add(interval);
        }
        return pq.size();
    }
}

266. Palindrome Permutation
class Solution {
    public boolean canPermutePalindrome(String s) {
        Map<Character,Integer> map=new HashMap<>();
        for(char a:s.toCharArray()){
            if(!map.containsKey(a)){
                map.put(a,1);
            }else{
                map.put(a,map.get(a)+1);
            }
        }
        List<Integer> list=new ArrayList(map.values());
        int count=0;
        for(int i=0;i<list.size();i++){
            if(list.get(i)%2!=0) count++;
        }
        return count<2;
    }
}

346. Moving Average from Data Stream
class MovingAverage {
    int size;
    int curSize;
    Queue<Integer> q=new LinkedList<>();
    double sum=0;
    /** Initialize your data structure here. */
    public MovingAverage(int size) {
        this.size=size;
        curSize=0;
    }
    
    public double next(int val) {
        curSize++;
        if(curSize<=size){
            q.add(val);
            sum+=val;
        }else{
            sum-=q.poll();
            curSize--;
            q.add(val);
            sum+=val;
        }
        return sum/curSize;
    }
}

373. Find K Pairs with Smallest Sums
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        List<List<Integer>> ans=new ArrayList<>();
        PriorityQueue<int[]> pq=new PriorityQueue<>((n1,n2)->((n1[0]+n1[1])-(n2[0]+n2[1])));
        int len1=nums1.length;
        int len2=nums2.length;
        if(len1==0||len2==0||k==0) return ans;
        for(int i=0;i<len1;i++){
            for(int j=0;j<len2;j++){
                pq.add(new int[]{nums1[i],nums2[j]});
            }
        }
        k=Math.min(k,len1*len2);
        while(k>0){
            int[] temp=pq.poll();
            List<Integer> list=Arrays.asList(temp[0],temp[1]);
            ans.add(list);
            k--;
        }
        return ans;
    }
}

380. Insert Delete GetRandom O(1)
class RandomizedSet {
    Map<Integer,Integer> map;
    List<Integer> list;
    Random rand=new Random();
    //map<val,pos>
    public RandomizedSet() {
        map=new HashMap<Integer,Integer>();
        list=new ArrayList<Integer>();
    }
    public boolean insert(int val) {
        if(map.containsKey(val)) return false;
        list.add(val);
        map.put(val,list.size()-1);
        return true;
    }
    public boolean remove(int val) {
        if(!map.containsKey(val)) return false;
        int index=map.get(val);
        int num=list.get(list.size()-1);
        list.set(index,num);
        list.remove(list.size()-1);
        map.put(num,index);
        map.remove(val);
        return true;
    }

    public int getRandom() {
        return list.get(rand.nextInt(list.size()));
    }
}

402. Remove K Digits
class Solution {
    public String removeKdigits(String num, int k) {
        int len=num.length();
        int remain=len-k;//remain digits that we need finally
        if(len==0||k>=len) return "0";
        //store the digit that we need
        Stack<Character> stack=new Stack<>();
        char[] digit=num.toCharArray();
        
        stack.push(digit[0]);
        
        for(int i=1;i<len;i++){
            //if we remove enough digits, we add all the rest into stack
            if(k==0){
                while(i<len){
                    stack.push(digit[i++]);
                }
                break;
            }
            //if we still need to remove digits,
            //when the curr digit is < previous, pop it out until curr>stack.peek(). 
            //break it if stack is empty and push the curr into stack.
            while(k>0&&digit[i]<stack.peek()){
                stack.pop();
                k--;
                if(stack.size()==0) break;
            }
            stack.push(digit[i]);
        }
        StringBuilder sb=new StringBuilder();
        //if we have more digits at the end, remove them
        while(stack.size()>remain){
            stack.pop();
        }
        Stack<Character> ans=new Stack<>();
        //reverse the stack and make it appendable in right order
        while(stack.size()>0){
            ans.push(stack.pop());
        }
        //remove the front 0, ex:0200 --> 200, 01 --> 1.
        //but 0 is still 0
        while(ans.size()>1&&ans.peek()=='0') ans.pop();
        
        while(ans.size()>0){
            sb.append(ans.pop());
        }
        return sb.toString();
    }
}

463. Island Perimeter
class Solution {
    int curPer=0;
    public int islandPerimeter(int[][] grid) {
        if(grid==null||grid.length==0) return 0;
        int row=grid.length,col=grid[0].length;
        
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(grid[i][j]==1){
                    check(grid,i,j);
                }
            }
        }
        return curPer;
    }
    
    public void check(int[][] grid, int r, int c){
        
        if(r-1>=0){
            if(grid[r-1][c]==0) curPer++;
        }else curPer++;
        if(r+1<grid.length){
            if(grid[r+1][c]==0) curPer++;
        }else curPer++;
        if(c-1>=0){
            if(grid[r][c-1]==0) curPer++;
        }else curPer++;
        if(c+1<grid[0].length){
            if(grid[r][c+1]==0) curPer++;
        }else curPer++;
        
    }
}

496. Next Greater Element I
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int[] ans=new int[nums1.length];
        Map<Integer,Integer> map=new HashMap<>();
        Stack<Integer> stack=new Stack<>();
        if(nums2.length!=0) stack.push(nums2[0]);
        
        for(int i=1;i<nums2.length;i++){
            while(!stack.isEmpty()&&stack.peek()<nums2[i]){
                map.put(stack.pop(),nums2[i]);
            }
            stack.push(nums2[i]);
        }
        while(!stack.isEmpty()){
            map.put(stack.pop(),-1);
        }
        int k=0;
        for(int num:nums1){
            ans[k++]=map.get(num);
        }
        return ans;
    }
}

572. Subtree of Another Tree
class Solution {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        if(s==null) return false;
        
        return check(s,t)||isSubtree(s.left,t)||isSubtree(s.right,t);
    }
    public boolean check(TreeNode s, TreeNode t){
        if(s==null&&t==null) return true;
        if(s==null||t==null) return false;
        return s.val==t.val&&check(s.left,t.left)&&check(s.right,t.right);
    }
}

653. Two Sum IV - Input is a BST
class Solution {
    public boolean findTarget(TreeNode root, int k) {
        if(root==null) return false;
        List<Integer> list=new ArrayList<>();
        inOrder(root,list);
        int left=0,right=list.size()-1;
        while(left<right){
            int sum=list.get(left)+list.get(right);
            if(sum<k) left++;
            else if(sum>k) right--;
            else return true;
        }
        return false;
    }
    public void inOrder(TreeNode root, List<Integer> list){
        if(root==null) return;
        inOrder(root.left,list);
        list.add(root.val);
        inOrder(root.right,list);
    }
}

695. Max Area of Island
class Solution {
    int area;
    public int maxAreaOfIsland(int[][] grid) {
        int row=grid.length;
        if(row==0) return 0;
        int col=grid[0].length;
        int maxArea=0;
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(grid[i][j]==1){
                    area=0;
                    dfs(grid,i,j);
                    maxArea=Math.max(maxArea,area);
                }
            }
        }
        return maxArea;
    }
    public void dfs(int[][] grid,int r,int c){
        if(r<0||c<0||r>=grid.length||c>=grid.length||grid[r][c]==0) return;
        grid[r][c]=0;
        area++;
        dfs(grid,r-1,c);
        dfs(grid,r+1,c);
        dfs(grid,r,c-1);
        dfs(grid,r,c+1);
    }
}

733. Flood Fill
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        if(image[sr][sc]==newColor) return image;
        dfs(image,sr,sc,image[sr][sc],newColor);
        return image;
    }
    public void dfs(int[][] image, int sr, int sc, int oldColor,int newColor){
        if(sr<0||sc<0||sr>=image.length||sc>=image[0].length||image[sr][sc]!=oldColor) return;
        image[sr][sc]=newColor;
        dfs(image,sr-1,sc,oldColor,newColor);
        dfs(image,sr+1,sc,oldColor,newColor);
        dfs(image,sr,sc-1,oldColor,newColor);
        dfs(image,sr,sc+1,oldColor,newColor);
    }
}

937. Reorder Data in Log Files
class Solution {
    public String[] reorderLogFiles(String[] logs) {
        
        List<String> diglist = new ArrayList<>();
        List<String> letlist = new ArrayList<>();
        for(String str:logs){
            if(str.charAt(str.indexOf(" ")+1)-'a'>=0&&str.charAt(str.indexOf(" ")+1)-'a'<26) letlist.add(str);
            else diglist.add(str);
        }
        
        Collections.sort(letlist,(c1,c2) ->{
            String[] s1=c1.split(" ");
            String[] s2=c2.split(" ");
            for(int i=1;i<Math.min(s1.length,s2.length);i++){
                if(!s1[i].equals(s2[i])){
                    return s1[i].compareTo(s2[i]);
                }
            }
            return s1[0].compareTo(s2[0]);
        });
        for(int i=0;i<logs.length;i++){
            if(i<letlist.size()) logs[i]=letlist.get(i);
            else logs[i]=diglist.get(i-letlist.size());
        }
        return logs;
        
    }
}

994. Rotting Oranges
class Solution {
    public int orangesRotting(int[][] grid) {
        //bfs, store the gird=2 into queue as root
        int row=grid.length;
        int col=grid[0].length;
        Queue<int[]> q=new LinkedList<>();
        int fresh=0;
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(grid[i][j]==2)
                    q.add(new int[] {i,j});
                else if(grid[i][j]==1) fresh++;
            }
        }
        if(fresh==0) return 0;
        //root level are in the q
        int level=0;
        while(!q.isEmpty()){
            if(fresh==0) break;
            int size=q.size();
            level++;
            for(int i=0;i<size;i++){
                int[] rotten=q.poll();
                int r=rotten[0];
                int c=rotten[1];
                if(r-1>=0&&grid[r-1][c]==1){
                    fresh--;
                    grid[r-1][c]=2;
                    q.add(new int[]{r-1,c});
                }
                if(c-1>=0&&grid[r][c-1]==1){
                    fresh--;
                    grid[r][c-1]=2;
                    q.add(new int[]{r,c-1});
                }
                if(r+1<grid.length&&grid[r+1][c]==1){
                    fresh--;
                    grid[r+1][c]=2;
                    q.add(new int[]{r+1,c});
                }
                if(c+1<grid[0].length&&grid[r][c+1]==1){
                    fresh--;
                    grid[r][c+1]=2;
                    q.add(new int[]{r,c+1});
                }
            }
            
        }
        if(fresh!=0) return -1;
        return level;
    }
}
